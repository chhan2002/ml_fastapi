# -*- coding: utf-8 -*-
"""feature_extraction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HZIMwPDCVXtVaIrYoMC141DsBEnSUpzP
"""

import numpy as np
from scipy.signal import find_peaks, savgol_filter
from scipy.integrate import simpson
from scipy.stats import skew
from scipy.fft import fft, fftfreq

def ensure_monotonic_voltage(voltage, current):
    """Sort by voltage if needed (some files may not be strictly monotonic)."""
    if not np.all(np.diff(voltage) > 0):
        order = np.argsort(voltage)
        voltage = voltage[order]
        current = current[order]
    return voltage, current

def linear_baseline(current, frac=0.05):
    """Fit a line to the first and last 'frac' of points and subtract it."""
    n = len(current)
    seg = max(5, int(frac * n))
    x = np.concatenate([np.arange(seg), np.arange(n - seg, n)])
    y = np.concatenate([current[:seg], current[-seg:]])
    coeffs = np.polyfit(x, y, 1)  # linear
    baseline = np.polyval(coeffs, np.arange(n))
    return current - baseline

def smooth_signal(current, max_window=21, polyorder=3):
    """Savitzkyâ€“Golay smoothing with adaptive odd window size."""
    n = len(current)
    if n < 7:
        return current
    win = min(max_window, n - 1 if (n % 2 == 0) else n)
    if win < 5:
        win = 5
    if win % 2 == 0:
        win += 1
    if polyorder >= win:
        polyorder = max(2, win - 1)
    return savgol_filter(current, window_length=win, polyorder=polyorder)

def fwhm(voltage, current, peak_idx):
    """Full width at half maximum around a given peak index."""
    if np.isnan(peak_idx):
        return np.nan
    peak_idx = int(peak_idx)
    I_peak = current[peak_idx]
    half = I_peak / 2.0

    left = None
    for i in range(peak_idx, 0, -1):
        if current[i] >= half and current[i - 1] < half:
            t = (half - current[i - 1]) / (current[i] - current[i - 1] + 1e-12)
            v_cross = voltage[i - 1] + t * (voltage[i] - voltage[i - 1])
            left = v_cross
            break

    right = None
    for i in range(peak_idx, len(current) - 1):
        if current[i] >= half and current[i + 1] < half:
            t = (half - current[i + 1]) / (current[i] - current[i + 1] + 1e-12)
            v_cross = voltage[i + 1] + t * (voltage[i] - voltage[i + 1])
            right = v_cross
            break

    if left is None or right is None:
        return np.nan
    return right - left

def extract_features(voltage, current, do_baseline=True, do_smooth=True):
    """Extract 22 handcrafted features for SWV signal classification."""
    feats = {}

    voltage, current = ensure_monotonic_voltage(voltage, current)
    cur_raw = current.copy()

    if do_baseline:
        current = linear_baseline(current, frac=0.05)
    if do_smooth:
        current = smooth_signal(current)

    # Basic statistics
    feats["I_max"] = float(np.max(current))
    feats["I_min"] = float(np.min(current))
    feats["I_mean"] = float(np.mean(current))
    feats["I_std"] = float(np.std(current))
    feats["I_range"] = feats["I_max"] - feats["I_min"]

    # Peak analysis
    thr = feats["I_mean"] + 0.5 * feats["I_std"]
    peaks, _ = find_peaks(current, height=thr)
    if len(peaks) > 0:
        main = peaks[np.argmax(current[peaks])]
        feats["V_peak"] = float(voltage[main])
        feats["I_peak"] = float(current[main])
        feats["Peak_width_FWHM"] = float(fwhm(voltage, current, main))

        a0 = max(0, main - 5)
        a1 = min(len(current), main + 6)
        feats["Peak_area_local"] = float(simpson(current[a0:a1], voltage[a0:a1]))

        w0 = max(0, main - 10)
        w1 = min(len(current), main + 11)
        feats["Peak_asymmetry_skew"] = float(skew(current[w0:w1]))

        dI_dV = np.gradient(current, voltage)
        feats["Slope_max_pre"] = float(np.max(dI_dV[w0:main + 1])) if main > w0 else float(np.nan)
        feats["Slope_min_post"] = float(np.min(dI_dV[main:w1])) if w1 > main else float(np.nan)
    else:
        feats["V_peak"] = np.nan
        feats["I_peak"] = np.nan
        feats["Peak_width_FWHM"] = np.nan
        feats["Peak_area_local"] = np.nan
        feats["Peak_asymmetry_skew"] = np.nan
        feats["Slope_max_pre"] = np.nan
        feats["Slope_min_post"] = np.nan

    # Derivatives
    dI_dV_full = np.gradient(current, voltage)
    feats["Slope_max"] = float(np.max(dI_dV_full))
    feats["Slope_min"] = float(np.min(dI_dV_full))
    feats["Mean_abs_slope"] = float(np.mean(np.abs(dI_dV_full)))

    # Area under curve
    feats["AUC_total"] = float(simpson(current, voltage))
    feats["AUC_positive"] = float(simpson(np.clip(current, 0, None), voltage))
    feats["AUC_negative"] = float(simpson(np.clip(current, None, 0), voltage))

    # Noise
    smoothed_for_noise = smooth_signal(linear_baseline(cur_raw) if do_baseline else cur_raw)
    feats["Noise_std"] = float(np.std(cur_raw - smoothed_for_noise))

    # FFT features
    dv = float(np.median(np.diff(voltage))) if len(voltage) > 1 else 1.0
    yf = np.abs(fft(current))
    xf = fftfreq(len(current), dv)

    if len(yf) > 1:
        idx = 1 + np.argmax(yf[1:])
        feats["FFT_peak_freq"] = float(xf[idx])
    else:
        feats["FFT_peak_freq"] = np.nan

    feats["FFT_power_total"] = float(np.sum(yf ** 2))
    feats["FFT_power_low"] = float(np.sum(yf[np.abs(xf) < 0.1] ** 2))
    feats["FFT_power_high"] = float(np.sum(yf[np.abs(xf) >= 0.1] ** 2))

    return feats